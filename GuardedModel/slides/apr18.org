#+title: A Guarded Syntactic Model of Gradual Dependent Types
#+AUTHOR: Joey Eremondi
#+date: April 18, 2022


#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [dvipsnames]
#+OPTIONS: toc:nil H:2 num:f
#+LATEX_COMPILER: xelatex

#+startup: beamer
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
# #+beamer: \beamerdefaultoverlayspecification{<+->}

#+LaTeX_HEADER: \usefonttheme[onlymath]{serif}


#+LaTeX_HEADER: \usepackage{xcolor}
#+LaTeX_HEADER: \usetheme{metropolis}
#+LaTeX_HEADER: \definecolor{ubcBlue}{RGB}{12,35,68}
#+LaTeX_HEADER: \definecolor{ubcBlue1}{RGB}{0,85,183}
#+LaTeX_HEADER: \definecolor{ubcBlue2}{RGB}{0,167,225}
#+LaTeX_HEADER: \definecolor{ubcBlue3}{RGB}{64,180,229}
#+LaTeX_HEADER: \definecolor{ubcBlue4}{RGB}{110,196,232}
#+LaTeX_HEADER: \definecolor{ubcBlue5}{RGB}{151,212,223}

#+LaTeX_HEADER: \setbeamercolor{alerted text}{bg=ubcBlue1, fg = ubcBlue}
#+LaTeX_HEADER: \setbeamercolor{example text}{fg=ubcBlue1, bg=ubcBlue1}
#+LaTeX_HEADER: \setbeamercolor{title separator}{fg = ubcBlue, bg=ubcBlue}
#+LaTeX_HEADER: \setbeamercolor{progress bar}{bg=ubcBlue4, fg=ubcBlue1}
#+LaTeX_HEADER: \setbeamercolor{progress bar in head/foot}{bg=ubcBlue4, fg=ubcBlue1}
#+LaTeX_HEADER: \setbeamercolor{progress bar in section page}{bg=ubcBlue4, fg=ubcBlue1}
#+LaTeX_HEADER: \setbeamercolor{frametitle}{bg=ubcBlue}

#+LaTeX_HEADER: \input{sharedmacros}

* Overview

** Two Problems - One Solution

*** Two Problems
- Implementing Gradual Dependent Types

- Denotational Semantics + Metatheory

**** One Soution

- Approximate Normalization + Translation to Static Dependent Types


* Implementing Gradual Dependent Types

** Don't Reinvent the Wheel

*** Long-term goal: gradual types in a full-scale dependent language


*** Machinery
- Many parts to dependent type checking and compilation
  + Compile-time evaluation for comparisons
  + Unification/inference
  + Code generation/optimization
- Want to avoid re-implementing as much of this as possible

*** Efficiency
- Normalizing/comparing types is expensive
- Want to leverage existing techniques
  + E.g. Idris: experimental normalization by compilation to ChezScheme



** Proposed Approach

*** Compile gradual dependent types to static dependent types /without changing the static core language/
- Can use existing normalization, unification, etc.

*** Challenge: Effects in gradual language
- Gradual languages: two effects
  + Failure (can just be modelled as special value in gradual language)
  + Non-termination
- Dependent languages restricted in how non-termination is used
  + Ensures consistency and decidablity of type checking

** The Idris model of Non-termination

*** Functions marked as "partial"
- Are not checked for termination/productivity
- Allows for general recursion


*** At compile-time
- Partial functions never normalized
- Conservative: some equivalent partial-terms may rejected as non-equal
   + need to normalize to /see/ that are equal
- Ensures type-checking terminates

** Problem with the Idris model
*** Ad-hoc, hard to reason about
- e.g. it's hard to prove that every gradual program translates to a well-typed
- Want formalism of Idris-style non-termination, so can prove translation proves
*** We will use Guarded Type Theory as a theoretical model of Idris
- More on this later

** Approximate Normalization
