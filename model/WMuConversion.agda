

{-# OPTIONS --cubical --guarded  #-}



-- open import Guarded
open import Cubical.Data.Maybe as Maybe
open import Level
open import Cubical.Relation.Nullary

open import DecPEq
open import Cubical.Data.Nat
open import Cubical.Data.Bool
open import Cubical.Data.Empty renaming (‚ä• to ùüò)
-- open import Cubical.Data.Prod
open import Cubical.Data.FinData
open import Cubical.Data.Sigma
open import Constructors
open import UnkGerm
open import GuardedAlgebra
open import Cubical.Induction.WellFounded
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Transport
open import Cubical.Data.Sum as Sum
open import GuardedModality using (later-ext)

open import GTypes
open import W

open import ApproxExact
open import Code
open import HeadDefs


--TODO: don't make ‚Ñì module param
module WMuConversion {{_ : DataTypes}} {{_ : DataGerms}}  where

-- We only ever attach a size to the approximate part of a computation
-- and we only need this conversion for making a size
private
  instance
    approx√Ü : √Ü
    approx√Ü = Approx



-- More direct interpretation of inductive descriptions
-- Works because we ensure the paramter types are always codes, not types
-- So we can stay in Set
-- Also, Cubical Agda recognizes these as strictly decreasing, which is nice
data ‚ÑÇDescEl' {‚Ñì} (X : Set) : {sig : IndSig} (cB : ‚ÑÇ ‚Ñì) ‚Üí  ‚ÑÇDesc cB sig ‚Üí ApproxEl cB ‚Üí Set where
  ElEnd : ‚àÄ {cB b} ‚Üí ‚ÑÇDescEl' X cB (CEnd) b
  ElArg : ‚àÄ {cB n cA sig b} {arity : ‚àÄ b ‚Üí HasArity HŒ† n (cA b)} {D : ‚ÑÇDesc _ sig} ‚Üí (a : El (cA b) ) ‚Üí  ‚ÑÇDescEl' X (CŒ£ cB cA)  D (b , approx a) ‚Üí ‚ÑÇDescEl' X cB (CArg cA arity D _ reflp) b
  ElRec : ‚àÄ {cB n b sig} {c : ApproxEl cB ‚Üí ‚ÑÇ ‚Ñì} {arity : ‚àÄ b ‚Üí HasArity HŒ£ n (c b)} {D : ‚ÑÇDesc cB sig} ‚Üí
    ((x : El (c b)) ‚Üí X ) ‚Üí ‚ÑÇDescEl' X cB D b ‚Üí ‚ÑÇDescEl' X cB  (CRec c arity D _ reflp) b



‚ÑÇDescEl : ‚àÄ  {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} ‚Üí ‚ÑÇDesc cB sig ‚Üí (X : Set) ‚Üí  ApproxEl cB ‚Üí Set
‚ÑÇDescEl {cB = cB} D X b = ‚ÑÇDescEl' X cB D b

  -- Fixed Points of inductive descriptions from codes
  -- We always ensure the first layer of descriptions is data-constructors
  -- Since we use these for comparing things for consistency

data ‚ÑÇŒº {‚Ñì} (tyCtor : CName) (D : DCtors ‚Ñì tyCtor)  : Set where
    Cinit : (d : DName tyCtor) ‚Üí ‚ÑÇDescEl {‚Ñì = ‚Ñì} (D d) (‚ÑÇŒº tyCtor D) Gtt ‚Üí ‚ÑÇŒº  tyCtor D
    CŒº‚Åá CŒº‚Ñß :  ‚ÑÇŒº tyCtor D


  -- ‚ÑÇŒº1 : ‚àÄ {‚Ñì} {cI : ‚ÑÇ ‚Ñì} (tyCtor : CName) (D : DName tyCtor ‚Üí ‚ÑÇDesc cI) (i : ApproxEl cI)  ‚Üí Set
  -- ‚ÑÇŒº1 tyCtor D = Œ£[ d ‚àà DName tyCtor ] ‚ÑÇDescEl (D d) (‚ÑÇŒº tyCtor D) i

WArg : ‚àÄ {‚Ñì} {tyCtor : CName} (D : DCtors ‚Ñì tyCtor) ‚Üí   Set
WArg D  = WÃÉ (Arg Œª d ‚Üí interpDesc (D d) Gtt) tt


  -- ‚ÑÇElFContainer : ‚àÄ {‚Ñì} {cI : ‚ÑÇ ‚Ñì} {i : ApproxEl cI} {X :  Set} ‚Üí {D : ‚ÑÇDesc cI} ‚Üí ‚ÑÇDescEl D X ‚â° FContainer (interpDesc D) X Unit i
  -- ‚ÑÇElFContainerExt : ‚àÄ {‚Ñì} {cI : ‚ÑÇ ‚Ñì} {i : ApproxEl cI} {X :  Set} ‚Üí {D : ‚ÑÇDesc cI} ‚Üí ‚ÑÇDescEl D ‚â° Œª X ‚Üí FContainer (interpDesc D) X Unit i

  -- Univalence gives us that this version of codes
  -- is identical to the version given by W-types
  -- don't know if we'll actually use this, but it was an important sanity check
  -- Proof is at the bottom of this file
  -- ‚ÑÇŒºWext : ‚àÄ {‚Ñì} {cI : ‚ÑÇ ‚Ñì}  {tyCtor : CName} {D : DCtors tyCtor }  ‚Üí
  --   ‚ÑÇŒº tyCtor D ‚â° WArg D


  -- ‚ÑÇŒºW : ‚àÄ {‚Ñì} {cI  : ‚ÑÇ ‚Ñì}  {tyCtor : CName} {D : DCtors tyCtor cI} {i : ApproxEl cI}  ‚Üí
  --   ‚ÑÇŒº tyCtor D ‚â° WArg D i




  ------------------------------------------
  -- Machinery for the isomorphism between W types and descriptions


fromCElCommand : ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} (D : ‚ÑÇDesc cB sig) {X :  Set} {b : ApproxEl cB}
    ‚Üí ‚ÑÇDescEl  D X b
    ‚Üí CommandD D b
fromCElCommand .(CEnd) (ElEnd) = tt
fromCElCommand (CArg _ _ D _ _) (ElArg a x) = a , fromCElCommand D x
fromCElCommand (CRec c _ D _ _) (ElRec f x) = fromCElCommand D x



fromCElF : ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} (D : ‚ÑÇDesc cB sig) {X :  Set} {b : ApproxEl cB}
    ‚Üí (x : ‚ÑÇDescEl  D X b)
    ‚Üí (r : ResponseD D b (fromCElCommand D x) )
        ‚Üí X
fromCElF (CArg c _ D _ _) (ElArg a x) r =  fromCElF D x r
fromCElF (CRec c _ D _ _) (ElRec f1 f2) (Rec a) =  f1 a
fromCElF (CRec c _ D _ _) (ElRec f1 f2) (Rest r) =  fromCElF D f2 r --fromCElF (D (approx a)) (f2 a) r



fromCŒº : ‚àÄ {‚Ñì} {tyCtor : CName} {D : DCtors ‚Ñì tyCtor}
    ‚Üí ‚ÑÇŒº tyCtor D
    ‚Üí WArg D
fromCEl : ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} {tyCtor : CName} (D : ‚ÑÇDesc cB sig) (E : DCtors ‚Ñì tyCtor) {b : ApproxEl cB}
    ‚Üí (x : ‚ÑÇDescEl  D (‚ÑÇŒº tyCtor E) b)
    ‚Üí (r : ResponseD D b (fromCElCommand D x))
        ‚Üí WArg E


fromCŒº {D = D} (Cinit d x) = Wsup (FC (d , fromCElCommand (D d) x) (fromCEl (D d) D x))
fromCŒº CŒº‚Åá = W‚Åá
fromCŒº CŒº‚Ñß = W‚Ñß

fromCEl (CArg c _ D _ _) E (ElArg a x) r = fromCEl D E x r
fromCEl (CRec c _ D _ _) E (ElRec f1 f2) (Rec a) = fromCŒº (f1 a)
fromCEl (CRec c _ D _ _) E (ElRec f1 f2) (Rest r) = fromCEl D E f2 r



toCEl :
  ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} {tyCtor : CName} (D : ‚ÑÇDesc cB sig) (E : DCtors ‚Ñì tyCtor ) {b : ApproxEl cB} ‚Üí
  (com : CommandD D b) ‚Üí
  (k : (r : ResponseD D b com ) ‚Üí
                WArg E)
  ‚Üí ‚ñ° {X = Œª _ ‚Üí WArg E} (interpDesc D b)
    (Œª (i , x) ‚Üí ‚ÑÇŒº tyCtor E)
    (tt , FC com k)
-- FContainer (interpDesc D) (Œª ‚Üí W (interpDesc E) Unit √ó ‚ÑÇŒº E i) Unit ix
  ‚Üí (‚ÑÇDescEl  D (‚ÑÇŒº tyCtor E) b)


toCŒº : ‚àÄ {‚Ñì} {tyCtor : CName} (D : DCtors ‚Ñì tyCtor)
  ‚Üí (x : WArg D)
  ‚Üí ‚ÑÇŒº tyCtor D
toCŒº D (Wsup (FC (d , com) resp)) = Cinit d (toCEl (D d) D com resp (Œª r ‚Üí toCŒº D (resp r)))
toCŒº D W‚Ñß = CŒº‚Ñß
toCŒº D W‚Åá = CŒº‚Åá


toCEl (CEnd) E _ k œÜ = ElEnd
toCEl (CArg c _ D _ reflp) E (a , com) k œÜ = ElArg a (toCEl D E com k œÜ)
toCEl (CRec c _ D _ reflp) E com k œÜ = ElRec (Œª a ‚Üí œÜ (Rec a)) (toCEl D E com (Œª r ‚Üí k (Rest r)) Œª r ‚Üí œÜ (Rest r))


toCElF :
  ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} {X :  Set} (D : ‚ÑÇDesc cB sig)   {b : ApproxEl cB} ‚Üí
  (com : CommandD D b) ‚Üí
  (k : (r : ResponseD D b com ) ‚Üí X)
  ‚Üí (‚ÑÇDescEl D X b)
toCElF (CEnd) wit k = ElEnd
toCElF (CArg c _ D _ reflp) (a , com) k = ElArg a (toCElF D com k)
toCElF (CRec c _ D _ reflp) com k = ElRec (Œª a ‚Üí k (Rec a)) (toCElF D com (Œª r ‚Üí k (Rest r)))
-- toCElF (CHGuard c D D‚ÇÅ) (com1 , com2) k = ElHGuard (Œª a ‚Üí toCElF D (com1 a) (Œª r ‚Üí k (GuardedArg (a , r))) ) (toCElF D‚ÇÅ com2 (Œª r ‚Üí k (GRest r)) )


fromToCElCommand :
  ‚àÄ {‚Ñì sig} {cB : ‚ÑÇ ‚Ñì} {tyCtor : CName} (D : ‚ÑÇDesc cB sig) (E : DCtors ‚Ñì tyCtor) {b : ApproxEl cB}
  ‚Üí (com : CommandD D b)
  ‚Üí (k : (r : ResponseD D b com ) ‚Üí
                WArg E)
  ‚Üí fromCElCommand D (toCEl D E com k Œª r ‚Üí toCŒº E (k r)) ‚â° com
fromToCElCommand (CEnd) E com k   = refl
fromToCElCommand (CArg c _ D _ reflp) E (a , com) k   = Œ£PathP (refl , fromToCElCommand D E com k  )
fromToCElCommand (CRec c _ D _ reflp) E com k   = fromToCElCommand D E com (Œª r ‚Üí k (Rest r))


-- fromToCElCommandF :
--   ‚àÄ {‚Ñì}  (D : ‚ÑÇDesc cI) {X :  Set}  {ix : ApproxEl cI}
--   ‚Üí (com : CommandD D ix)
--   ‚Üí (k : (r : ResponseD D com ) ‚Üí
--                   X (inextD D com r))
--   ‚Üí fromCElCommand D (toCElF {X = X} D com k) ‚â° com
-- fromToCElCommandF (CEnd i) com k   = refl
-- fromToCElCommandF (CArg c _ D) (a , com) k   = Œ£PathP (refl , fromToCElCommandF (D (approx a)) com k  )
-- fromToCElCommandF (CRec j D) com k   = fromToCElCommandF D com (Œª r ‚Üí k (Rest r))
-- fromToCElCommandF (CRec c j D) com k   = funExt Œª a ‚Üí fromToCElCommandF (D (approx a)) (com a) (Œª r ‚Üí k (Rest (a , r)))
-- -- fromToCElCommandF (CHGuard c D D‚ÇÅ) (com1 , com2) k   =
--   -- ‚â°-√ó
--   --   (funExt (Œª a ‚Üí fromToCElCommandF D (com1 a) (Œª r ‚Üí k (GuardedArg (a , r)))  ))
--   --   (fromToCElCommandF D‚ÇÅ com2 (Œª r ‚Üí k (GRest r))  )
